// Code generated by template-generator; DO NOT EDIT.

package {{.PackageName}}

import (
	"fmt"
	"github.com/a-h/templ"
	"github.com/denkhaus/templ-router/pkg/interfaces"
	"github.com/samber/do/v2"
{{- range .Imports}}
	{{.Alias}} "{{.Path}}"
{{- end}}
)

// TemplateRegistry implements interfaces.TemplateRegistry
type TemplateRegistry struct {
	templates    map[string]interface{}
	routeMapping map[string]string
}

// NewTemplateRegistry creates a new template registry for DI
func NewTemplateRegistry(i do.Injector) (interfaces.TemplateRegistry, error) {
	return &TemplateRegistry{
		templates: map[string]interface{}{
{{- range .Templates}}
			"{{.TemplateKey}}": {{.PackageAlias}}.{{.FunctionName}},
{{- end}}
		},
		routeMapping: map[string]string{
{{- range .Templates}}
			"{{.RoutePattern}}": "{{.TemplateKey}}",
{{- end}}
		},
	}, nil
}

// GetTemplate retrieves a template component by key
func (r *TemplateRegistry) GetTemplate(key string) (templ.Component, error) {
	if templateFunc, exists := r.templates[key]; exists {
		// Handle different template function signatures
		switch fn := templateFunc.(type) {
		case func() templ.Component:
			return fn(), nil
		case func(string) templ.Component:
			// For parameterized templates, we need parameters from context
			// This is a simplified implementation - in practice, parameters would come from request context
			return fn(""), nil
		case func(interface{}) templ.Component:
			// For templates with complex parameters
			return fn(nil), nil
		default:
			return nil, fmt.Errorf("unsupported template function type for key: %s", key)
		}
	}
	return nil, fmt.Errorf("template not found: %s", key)
}

// GetTemplateFunction retrieves a template function by key
func (r *TemplateRegistry) GetTemplateFunction(key string) (func() interface{}, bool) {
	if templateFunc, exists := r.templates[key]; exists {
		// Return the template function as func() interface{} to support parameterized components
		return func() interface{} {
			return templateFunc
		}, true
	}
	return nil, false
}

// GetAllTemplateKeys returns all available template keys
func (r *TemplateRegistry) GetAllTemplateKeys() []string {
	keys := make([]string, 0, len(r.templates))
	for key := range r.templates {
		keys = append(keys, key)
	}
	return keys
}

// IsAvailable checks if a template exists
func (r *TemplateRegistry) IsAvailable(key string) bool {
	_, exists := r.templates[key]
	return exists
}

// GetRouteToTemplateMapping returns the route-to-template mapping
func (r *TemplateRegistry) GetRouteToTemplateMapping() map[string]string {
	return r.routeMapping
}

// GetTemplateByRoute retrieves a template component by route pattern
func (r *TemplateRegistry) GetTemplateByRoute(route string) (templ.Component, error) {
	if templateKey, exists := r.routeMapping[route]; exists {
		return r.GetTemplate(templateKey)
	}
	return nil, fmt.Errorf("no template found for route: %s", route)
}
