// Code generated by template-generator {{.GeneratorVersion}}; DO NOT EDIT.
// Generated at: {{.GeneratedAt}}

package {{.PackageName}}

import (
	"fmt"
	"github.com/a-h/templ"
	"github.com/denkhaus/templ-router/pkg/interfaces"
	"github.com/samber/do/v2"
{{- range .Imports}}
	{{.Alias}} "{{.Path}}"
{{- end}}
)

// TemplateRegistry implements interfaces.TemplateRegistry
type templateRegistryImpl struct {
	templates    map[string]interface{}
	routeMapping map[string]string
	dataServices map[string]interfaces.DataServiceInfo
}

// NewRegistry creates a new template registry for DI
func NewRegistry(i do.Injector) (interfaces.TemplateRegistry, error) {
	registry := &templateRegistryImpl{
		templates: map[string]interface{}{
{{- range .Templates}}
			"{{.TemplateKey}}": {{.PackageAlias}}.{{.FunctionName}},
{{- end}}
		},
		routeMapping: map[string]string{
{{- range .Templates}}
			"{{.RoutePattern}}": "{{.TemplateKey}}",
{{- end}}
		},
		dataServices: map[string]interfaces.DataServiceInfo{
{{- range .Templates}}
{{- if .RequiresDataService}}
			"{{.TemplateKey}}": {
				InterfaceType: "{{.DataServiceInterface}}",
				ParameterType: "{{.DataParameterType}}",
			},
{{- end}}
{{- end}}
		},
	}
	
	return registry, nil
}

// GetTemplate retrieves a template component by key
func (r *templateRegistryImpl) GetTemplate(key string) (templ.Component, error) {
	if templateFunc, exists := r.templates[key]; exists {
		// Handle different template function signatures
		switch fn := templateFunc.(type) {
		case func() templ.Component:
			return fn(), nil
		case func(string) templ.Component:
			// For parameterized templates, we need parameters from context
			// This is a simplified implementation - in practice, parameters would come from request context
			return fn(""), nil
		case func(interface{}) templ.Component:
			// For templates with complex parameters
			return fn(nil), nil
		default:
			return nil, fmt.Errorf("unsupported template function type for key: %s", key)
		}
	}
	return nil, fmt.Errorf("template not found: %s", key)
}

// GetTemplateFunction retrieves a template function by key
func (r *templateRegistryImpl) GetTemplateFunction(key string) (func() interface{}, bool) {
	if templateFunc, exists := r.templates[key]; exists {
		// Return the template function as func() interface{} to support parameterized components
		return func() interface{} {
			return templateFunc
		}, true
	}
	return nil, false
}

// GetAllTemplateKeys returns all available template keys
func (r *templateRegistryImpl) GetAllTemplateKeys() []string {
	keys := make([]string, 0, len(r.templates))
	for key := range r.templates {
		keys = append(keys, key)
	}
	return keys
}

// IsAvailable checks if a template exists
func (r *templateRegistryImpl) IsAvailable(key string) bool {
	_, exists := r.templates[key]
	return exists
}

// GetRouteToTemplateMapping returns the route-to-template mapping
func (r *templateRegistryImpl) GetRouteToTemplateMapping() map[string]string {
	return r.routeMapping
}

// GetTemplateByRoute retrieves a template component by route pattern
func (r *templateRegistryImpl) GetTemplateByRoute(route string) (templ.Component, error) {
	if templateKey, exists := r.routeMapping[route]; exists {
		return r.GetTemplate(templateKey)
	}
	return nil, fmt.Errorf("no template found for route: %s", route)
}

// RequiresDataService checks if a template requires a data service
func (r *templateRegistryImpl) RequiresDataService(key string) bool {
	_, exists := r.dataServices[key]
	return exists
}

// GetDataServiceInfo retrieves data service information for a template
func (r *templateRegistryImpl) GetDataServiceInfo(key string) (interfaces.DataServiceInfo, bool) {
	info, exists := r.dataServices[key]
	return info, exists
}
